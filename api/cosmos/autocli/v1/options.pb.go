// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/autocli/v1/options.proto

package autocliv1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModuleOptions describes the CLI options for a Cosmos SDK module.
type ModuleOptions struct {
	// tx describes the tx commands for the module.
	Tx *ServiceCommandDescriptor `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	// query describes the queries commands for the module.
	Query *ServiceCommandDescriptor `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *ModuleOptions) Reset()         { *m = ModuleOptions{} }
func (m *ModuleOptions) String() string { return proto.CompactTextString(m) }
func (*ModuleOptions) ProtoMessage()    {}
func (*ModuleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_da69909b95ea5a55, []int{0}
}
func (m *ModuleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleOptions.Merge(m, src)
}
func (m *ModuleOptions) XXX_Size() int {
	return m.Size()
}
func (m *ModuleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleOptions proto.InternalMessageInfo

func (m *ModuleOptions) GetTx() *ServiceCommandDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *ModuleOptions) GetQuery() *ServiceCommandDescriptor {
	if m != nil {
		return m.Query
	}
	return nil
}

// ServiceCommandDescriptor describes a CLI command based on a protobuf service.
type ServiceCommandDescriptor struct {
	// service is the fully qualified name of the protobuf service to build
	// the command from. It can be left empty if sub_commands are used instead
	// which may be the case if a module provides multiple tx and/or query services.
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	// rpc_command_options are options for commands generated from rpc methods.
	// If no options are specified for a given rpc method on the service, a
	// command will be generated for that method with the default options.
	RpcCommandOptions []*RpcCommandOptions `protobuf:"bytes,2,rep,name=rpc_command_options,json=rpcCommandOptions,proto3" json:"rpc_command_options,omitempty"`
	// sub_commands is a map of optional sub-commands for this command based on
	// different protobuf services. The map key is used as the name of the
	// sub-command.
	SubCommands map[string]*ServiceCommandDescriptor `protobuf:"bytes,3,rep,name=sub_commands,json=subCommands,proto3" json:"sub_commands,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// enhance_custom_commands specifies whether to skip the service when generating commands, if a custom command already
	// exists, or enhance the existing command. If set to true, the custom command will be enhanced with the services from
	// gRPC. otherwise when a custom command exists, no commands will be generated for the service.
	EnhanceCustomCommand bool `protobuf:"varint,4,opt,name=enhance_custom_command,json=enhanceCustomCommand,proto3" json:"enhance_custom_command,omitempty"`
}

func (m *ServiceCommandDescriptor) Reset()         { *m = ServiceCommandDescriptor{} }
func (m *ServiceCommandDescriptor) String() string { return proto.CompactTextString(m) }
func (*ServiceCommandDescriptor) ProtoMessage()    {}
func (*ServiceCommandDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_da69909b95ea5a55, []int{1}
}
func (m *ServiceCommandDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceCommandDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceCommandDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceCommandDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceCommandDescriptor.Merge(m, src)
}
func (m *ServiceCommandDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ServiceCommandDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceCommandDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceCommandDescriptor proto.InternalMessageInfo

func (m *ServiceCommandDescriptor) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ServiceCommandDescriptor) GetRpcCommandOptions() []*RpcCommandOptions {
	if m != nil {
		return m.RpcCommandOptions
	}
	return nil
}

func (m *ServiceCommandDescriptor) GetSubCommands() map[string]*ServiceCommandDescriptor {
	if m != nil {
		return m.SubCommands
	}
	return nil
}

func (m *ServiceCommandDescriptor) GetEnhanceCustomCommand() bool {
	if m != nil {
		return m.EnhanceCustomCommand
	}
	return false
}

// RpcCommandOptions specifies options for commands generated from protobuf
// rpc methods.
type RpcCommandOptions struct {
	// rpc_method is short name of the protobuf rpc method that this command is
	// generated from.
	RpcMethod string `protobuf:"bytes,1,opt,name=rpc_method,json=rpcMethod,proto3" json:"rpc_method,omitempty"`
	// use is the one-line usage method. It also allows specifying an alternate
	// name for the command as the first word of the usage text.
	//
	// By default the name of an rpc command is the kebab-case short name of the
	// rpc method.
	Use string `protobuf:"bytes,2,opt,name=use,proto3" json:"use,omitempty"`
	// long is the long message shown in the 'help <this-command>' output.
	Long string `protobuf:"bytes,3,opt,name=long,proto3" json:"long,omitempty"`
	// short is the short description shown in the 'help' output.
	Short string `protobuf:"bytes,4,opt,name=short,proto3" json:"short,omitempty"`
	// example is examples of how to use the command.
	Example string `protobuf:"bytes,5,opt,name=example,proto3" json:"example,omitempty"`
	// alias is an array of aliases that can be used instead of the first word in Use.
	Alias []string `protobuf:"bytes,6,rep,name=alias,proto3" json:"alias,omitempty"`
	// suggest_for is an array of command names for which this command will be suggested -
	// similar to aliases but only suggests.
	SuggestFor []string `protobuf:"bytes,7,rep,name=suggest_for,json=suggestFor,proto3" json:"suggest_for,omitempty"`
	// deprecated defines, if this command is deprecated and should print this string when used.
	Deprecated string `protobuf:"bytes,8,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// version defines the version for this command. If this value is non-empty and the command does not
	// define a "version" flag, a "version" boolean flag will be added to the command and, if specified,
	// will print content of the "Version" variable. A shorthand "v" flag will also be added if the
	// command does not define one.
	Version string `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	// flag_options are options for flags generated from rpc request fields.
	// By default all request fields are configured as flags. They can
	// also be configured as positional args instead using positional_args.
	FlagOptions map[string]*FlagOptions `protobuf:"bytes,10,rep,name=flag_options,json=flagOptions,proto3" json:"flag_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// positional_args specifies positional arguments for the command.
	PositionalArgs []*PositionalArgDescriptor `protobuf:"bytes,11,rep,name=positional_args,json=positionalArgs,proto3" json:"positional_args,omitempty"`
	// skip specifies whether to skip this rpc method when generating commands.
	Skip bool `protobuf:"varint,12,opt,name=skip,proto3" json:"skip,omitempty"`
	// gov_proposal specifies whether autocli should generate a gov proposal transaction for this rpc method.
	// Normally autocli generates a transaction containing the message and broadcast it.
	// However, when true, autocli generates a proposal transaction containing the message and broadcast it.
	// This option is ineffective for query commands.
	//
	// Since: client/v2 v2.0.0-beta.2
	GovProposal bool `protobuf:"varint,13,opt,name=gov_proposal,json=govProposal,proto3" json:"gov_proposal,omitempty"`
}

func (m *RpcCommandOptions) Reset()         { *m = RpcCommandOptions{} }
func (m *RpcCommandOptions) String() string { return proto.CompactTextString(m) }
func (*RpcCommandOptions) ProtoMessage()    {}
func (*RpcCommandOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_da69909b95ea5a55, []int{2}
}
func (m *RpcCommandOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcCommandOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcCommandOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcCommandOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcCommandOptions.Merge(m, src)
}
func (m *RpcCommandOptions) XXX_Size() int {
	return m.Size()
}
func (m *RpcCommandOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcCommandOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RpcCommandOptions proto.InternalMessageInfo

func (m *RpcCommandOptions) GetRpcMethod() string {
	if m != nil {
		return m.RpcMethod
	}
	return ""
}

func (m *RpcCommandOptions) GetUse() string {
	if m != nil {
		return m.Use
	}
	return ""
}

func (m *RpcCommandOptions) GetLong() string {
	if m != nil {
		return m.Long
	}
	return ""
}

func (m *RpcCommandOptions) GetShort() string {
	if m != nil {
		return m.Short
	}
	return ""
}

func (m *RpcCommandOptions) GetExample() string {
	if m != nil {
		return m.Example
	}
	return ""
}

func (m *RpcCommandOptions) GetAlias() []string {
	if m != nil {
		return m.Alias
	}
	return nil
}

func (m *RpcCommandOptions) GetSuggestFor() []string {
	if m != nil {
		return m.SuggestFor
	}
	return nil
}

func (m *RpcCommandOptions) GetDeprecated() string {
	if m != nil {
		return m.Deprecated
	}
	return ""
}

func (m *RpcCommandOptions) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RpcCommandOptions) GetFlagOptions() map[string]*FlagOptions {
	if m != nil {
		return m.FlagOptions
	}
	return nil
}

func (m *RpcCommandOptions) GetPositionalArgs() []*PositionalArgDescriptor {
	if m != nil {
		return m.PositionalArgs
	}
	return nil
}

func (m *RpcCommandOptions) GetSkip() bool {
	if m != nil {
		return m.Skip
	}
	return false
}

func (m *RpcCommandOptions) GetGovProposal() bool {
	if m != nil {
		return m.GovProposal
	}
	return false
}

// FlagOptions are options for flags generated from rpc request fields.
// By default, all request fields are configured as flags based on the
// kebab-case name of the field. Fields can be turned into positional arguments
// instead by using RpcCommandOptions.positional_args.
type FlagOptions struct {
	// name is an alternate name to use for the field flag.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// shorthand is a one-letter abbreviated flag.
	Shorthand string `protobuf:"bytes,2,opt,name=shorthand,proto3" json:"shorthand,omitempty"`
	// usage is the help message.
	Usage string `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	// default_value is the default value as text.
	DefaultValue string `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	// deprecated is the usage text to show if this flag is deprecated.
	Deprecated string `protobuf:"bytes,6,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// shorthand_deprecated is the usage text to show if the shorthand of this flag is deprecated.
	ShorthandDeprecated string `protobuf:"bytes,7,opt,name=shorthand_deprecated,json=shorthandDeprecated,proto3" json:"shorthand_deprecated,omitempty"`
	// hidden hides the flag from help/usage text
	Hidden bool `protobuf:"varint,8,opt,name=hidden,proto3" json:"hidden,omitempty"`
}

func (m *FlagOptions) Reset()         { *m = FlagOptions{} }
func (m *FlagOptions) String() string { return proto.CompactTextString(m) }
func (*FlagOptions) ProtoMessage()    {}
func (*FlagOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_da69909b95ea5a55, []int{3}
}
func (m *FlagOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlagOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlagOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlagOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlagOptions.Merge(m, src)
}
func (m *FlagOptions) XXX_Size() int {
	return m.Size()
}
func (m *FlagOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FlagOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FlagOptions proto.InternalMessageInfo

func (m *FlagOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FlagOptions) GetShorthand() string {
	if m != nil {
		return m.Shorthand
	}
	return ""
}

func (m *FlagOptions) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

func (m *FlagOptions) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

func (m *FlagOptions) GetDeprecated() string {
	if m != nil {
		return m.Deprecated
	}
	return ""
}

func (m *FlagOptions) GetShorthandDeprecated() string {
	if m != nil {
		return m.ShorthandDeprecated
	}
	return ""
}

func (m *FlagOptions) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

// PositionalArgDescriptor describes a positional argument.
type PositionalArgDescriptor struct {
	// proto_field specifies the proto field to use as the positional arg. Any
	// fields used as positional args will not have a flag generated.
	ProtoField string `protobuf:"bytes,1,opt,name=proto_field,json=protoField,proto3" json:"proto_field,omitempty"`
	// varargs makes a positional parameter a varargs parameter. This can only be
	// applied to last positional parameter and the proto_field must a repeated
	// field. Note: It is mutually exclusive with optional.
	Varargs bool `protobuf:"varint,2,opt,name=varargs,proto3" json:"varargs,omitempty"`
	// optional makes the last positional parameter optional.
	// Note: It is mutually exclusive with varargs.
	Optional bool `protobuf:"varint,3,opt,name=optional,proto3" json:"optional,omitempty"`
}

func (m *PositionalArgDescriptor) Reset()         { *m = PositionalArgDescriptor{} }
func (m *PositionalArgDescriptor) String() string { return proto.CompactTextString(m) }
func (*PositionalArgDescriptor) ProtoMessage()    {}
func (*PositionalArgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_da69909b95ea5a55, []int{4}
}
func (m *PositionalArgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionalArgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionalArgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionalArgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionalArgDescriptor.Merge(m, src)
}
func (m *PositionalArgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *PositionalArgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionalArgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_PositionalArgDescriptor proto.InternalMessageInfo

func (m *PositionalArgDescriptor) GetProtoField() string {
	if m != nil {
		return m.ProtoField
	}
	return ""
}

func (m *PositionalArgDescriptor) GetVarargs() bool {
	if m != nil {
		return m.Varargs
	}
	return false
}

func (m *PositionalArgDescriptor) GetOptional() bool {
	if m != nil {
		return m.Optional
	}
	return false
}

func init() {
	proto.RegisterType((*ModuleOptions)(nil), "cosmos.autocli.v1.ModuleOptions")
	proto.RegisterType((*ServiceCommandDescriptor)(nil), "cosmos.autocli.v1.ServiceCommandDescriptor")
	proto.RegisterMapType((map[string]*ServiceCommandDescriptor)(nil), "cosmos.autocli.v1.ServiceCommandDescriptor.SubCommandsEntry")
	proto.RegisterType((*RpcCommandOptions)(nil), "cosmos.autocli.v1.RpcCommandOptions")
	proto.RegisterMapType((map[string]*FlagOptions)(nil), "cosmos.autocli.v1.RpcCommandOptions.FlagOptionsEntry")
	proto.RegisterType((*FlagOptions)(nil), "cosmos.autocli.v1.FlagOptions")
	proto.RegisterType((*PositionalArgDescriptor)(nil), "cosmos.autocli.v1.PositionalArgDescriptor")
}

func init() { proto.RegisterFile("cosmos/autocli/v1/options.proto", fileDescriptor_da69909b95ea5a55) }

var fileDescriptor_da69909b95ea5a55 = []byte{
	// 799 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xae, 0x9d, 0x7e, 0x24, 0x6f, 0x52, 0x68, 0xa7, 0x65, 0x19, 0x55, 0xac, 0xb7, 0x14, 0x0e,
	0x15, 0x20, 0x47, 0x59, 0x16, 0x09, 0x65, 0xb9, 0xb4, 0x59, 0xca, 0xa9, 0x22, 0x72, 0x51, 0xb4,
	0x42, 0x15, 0xd6, 0xd4, 0x9e, 0x38, 0x56, 0x6c, 0x8f, 0x99, 0xb1, 0xad, 0xf6, 0x4f, 0x00, 0xbf,
	0x81, 0x23, 0x7f, 0x82, 0x2b, 0xe2, 0xb4, 0xdc, 0x38, 0xa2, 0x54, 0x5c, 0xf8, 0x15, 0x68, 0x3e,
	0xf2, 0x41, 0x92, 0x95, 0xe8, 0xde, 0xde, 0xf7, 0x79, 0x3f, 0xe7, 0x7d, 0x1e, 0x27, 0xf0, 0x24,
	0x60, 0x22, 0x65, 0xa2, 0x4d, 0xca, 0x82, 0x05, 0x49, 0xdc, 0xae, 0x3a, 0x6d, 0x96, 0x17, 0x31,
	0xcb, 0x84, 0x9b, 0x73, 0x56, 0x30, 0xb4, 0xaf, 0x13, 0x5c, 0x93, 0xe0, 0x56, 0x9d, 0x93, 0x1f,
	0x2d, 0xd8, 0xbd, 0x64, 0x61, 0x99, 0xd0, 0xaf, 0x75, 0x2a, 0x7a, 0x0e, 0x76, 0x71, 0x8b, 0xad,
	0x63, 0xeb, 0xb4, 0xf9, 0xf4, 0x63, 0x77, 0xa5, 0xc2, 0xbd, 0xa2, 0xbc, 0x8a, 0x03, 0xda, 0x63,
	0x69, 0x4a, 0xb2, 0xf0, 0x05, 0x15, 0x01, 0x8f, 0xf3, 0x82, 0x71, 0xcf, 0x2e, 0x6e, 0xd1, 0x19,
	0x6c, 0x7d, 0x5f, 0x52, 0x7e, 0x87, 0xed, 0x87, 0xd7, 0xeb, 0xca, 0x93, 0x1f, 0x6a, 0x80, 0x5f,
	0x97, 0x83, 0x30, 0xec, 0x08, 0x1d, 0x53, 0x1b, 0x36, 0xbc, 0xa9, 0x8b, 0xbe, 0x81, 0x03, 0x9e,
	0x07, 0x7e, 0xa0, 0x4b, 0x7c, 0xf3, 0x70, 0x6c, 0x1f, 0xd7, 0x4e, 0x9b, 0x4f, 0x3f, 0x5c, 0xb3,
	0x87, 0x97, 0x07, 0xa6, 0xbf, 0x79, 0xb9, 0xb7, 0xcf, 0x97, 0x21, 0xe4, 0x43, 0x4b, 0x94, 0x37,
	0xd3, 0xae, 0x02, 0xd7, 0x54, 0xbb, 0x2f, 0x1e, 0xf0, 0x2c, 0xf7, 0xaa, 0xbc, 0x31, 0xa0, 0xf8,
	0x32, 0x2b, 0xf8, 0x9d, 0xd7, 0x14, 0x73, 0x04, 0x3d, 0x83, 0x47, 0x34, 0x1b, 0x91, 0x2c, 0xa0,
	0x7e, 0x50, 0x8a, 0x82, 0xa5, 0xd3, 0x59, 0x78, 0xf3, 0xd8, 0x3a, 0xad, 0x7b, 0x87, 0x26, 0xda,
	0x53, 0x41, 0x53, 0x76, 0x34, 0x86, 0xbd, 0xe5, 0xb6, 0x68, 0x0f, 0x6a, 0x63, 0x7a, 0x67, 0xce,
	0x22, 0x4d, 0x49, 0x46, 0x45, 0x92, 0x92, 0xbe, 0x11, 0x19, 0xaa, 0xb2, 0x6b, 0x7f, 0x6e, 0x9d,
	0xfc, 0xba, 0x09, 0xfb, 0x2b, 0xc7, 0x42, 0x8f, 0x01, 0xe4, 0xbd, 0x53, 0x5a, 0x8c, 0x58, 0x68,
	0xa6, 0x36, 0x78, 0x1e, 0x5c, 0x2a, 0x40, 0x6e, 0x53, 0x0a, 0x3d, 0xb9, 0xe1, 0x49, 0x13, 0x21,
	0xd8, 0x4c, 0x58, 0x16, 0xe1, 0x9a, 0x82, 0x94, 0x8d, 0x0e, 0x61, 0x4b, 0x8c, 0x18, 0x2f, 0xd4,
	0x63, 0x1b, 0x9e, 0x76, 0x24, 0xc9, 0xf4, 0x96, 0xa4, 0x79, 0x42, 0xf1, 0x96, 0x26, 0xd9, 0xb8,
	0x32, 0x9f, 0x24, 0x31, 0x11, 0x78, 0xfb, 0xb8, 0x26, 0xf3, 0x95, 0x83, 0x9e, 0x40, 0x53, 0x94,
	0x51, 0x44, 0x45, 0xe1, 0x0f, 0x19, 0xc7, 0x3b, 0x2a, 0x06, 0x06, 0xba, 0x60, 0x1c, 0x39, 0x00,
	0x21, 0xcd, 0x39, 0x0d, 0x48, 0x41, 0x43, 0x5c, 0x57, 0x3d, 0x17, 0x10, 0x39, 0xb0, 0xa2, 0x5c,
	0xc4, 0x2c, 0xc3, 0x0d, 0x3d, 0xd0, 0xb8, 0xe8, 0x25, 0xb4, 0x86, 0x09, 0x89, 0x66, 0x72, 0x02,
	0xc5, 0xff, 0x67, 0xff, 0x47, 0x4e, 0xee, 0x45, 0x42, 0x22, 0x63, 0x1b, 0xe2, 0x87, 0x73, 0x04,
	0x5d, 0xc1, 0xdb, 0x39, 0x13, 0xb1, 0x74, 0x48, 0xe2, 0x13, 0x1e, 0x09, 0xdc, 0x54, 0xcd, 0x3f,
	0x5a, 0xd3, 0xbc, 0x3f, 0xcb, 0x3c, 0xe3, 0xd1, 0x02, 0x4b, 0x6f, 0xe5, 0x8b, 0x01, 0x21, 0x6f,
	0x2c, 0xc6, 0x71, 0x8e, 0x5b, 0x4a, 0x3b, 0xca, 0x46, 0xef, 0x43, 0x2b, 0x62, 0x95, 0x9f, 0x73,
	0x96, 0x33, 0x41, 0x12, 0xbc, 0xab, 0x62, 0xcd, 0x88, 0x55, 0x7d, 0x03, 0x1d, 0x7d, 0x07, 0x7b,
	0xcb, 0xcb, 0xae, 0x91, 0xd3, 0xb3, 0xff, 0xca, 0xc9, 0x59, 0xb3, 0xe7, 0x42, 0x97, 0x45, 0x05,
	0xfd, 0x6d, 0x41, 0x73, 0x21, 0x24, 0xd7, 0xcc, 0x48, 0x3a, 0xfd, 0x84, 0x95, 0x8d, 0xde, 0x83,
	0x86, 0x62, 0x7f, 0x24, 0xb5, 0xaf, 0x65, 0x33, 0x07, 0x24, 0xf1, 0xa5, 0x20, 0x11, 0x35, 0xea,
	0xd1, 0x0e, 0xfa, 0x00, 0x76, 0x43, 0x3a, 0x24, 0x65, 0x52, 0xf8, 0x7a, 0x33, 0x2d, 0xa3, 0x96,
	0x01, 0x07, 0x12, 0x5b, 0x22, 0x7f, 0x7b, 0x85, 0xfc, 0x0e, 0x1c, 0xce, 0xe6, 0xf8, 0x0b, 0x99,
	0x3b, 0x2a, 0xf3, 0x60, 0x16, 0x7b, 0x31, 0x2f, 0x79, 0x04, 0xdb, 0xa3, 0x38, 0x0c, 0x69, 0xa6,
	0xb4, 0x54, 0xf7, 0x8c, 0x77, 0x92, 0xc3, 0xbb, 0xaf, 0x61, 0x4a, 0x6a, 0x54, 0xfd, 0x06, 0xfb,
	0xc3, 0x98, 0x26, 0xd3, 0xef, 0x05, 0x14, 0x74, 0x21, 0x11, 0xa5, 0x41, 0xc2, 0x95, 0x0e, 0x6c,
	0xd5, 0x74, 0xea, 0xa2, 0x23, 0xa8, 0x6b, 0xf9, 0x91, 0x44, 0x3d, 0xbf, 0xee, 0xcd, 0xfc, 0xf3,
	0x3f, 0xac, 0xdf, 0x26, 0x8e, 0xf5, 0x6a, 0xe2, 0x58, 0x7f, 0x4d, 0x1c, 0xeb, 0xa7, 0x7b, 0x67,
	0xe3, 0xd5, 0xbd, 0xb3, 0xf1, 0xe7, 0xbd, 0xb3, 0x01, 0xef, 0x04, 0x2c, 0x5d, 0xa5, 0xe8, 0xbc,
	0x65, 0x48, 0xe8, 0xcb, 0xd1, 0x7d, 0xeb, 0xdb, 0x4f, 0x74, 0x8a, 0x08, 0xc7, 0x6e, 0xcc, 0xda,
	0x24, 0x8f, 0xdb, 0x2b, 0xff, 0x22, 0xcf, 0x8d, 0x59, 0x75, 0x7e, 0xb6, 0x6b, 0xbd, 0xb3, 0x97,
	0xbf, 0xd8, 0xfb, 0x3d, 0xdd, 0xf7, 0xcc, 0xf4, 0x1d, 0x74, 0x7e, 0x9f, 0x62, 0xd7, 0x06, 0xbb,
	0x1e, 0x74, 0x26, 0xf6, 0xe3, 0x15, 0xec, 0xfa, 0xab, 0xfe, 0xf9, 0x25, 0x2d, 0x48, 0x48, 0x0a,
	0xf2, 0x8f, 0x7d, 0xa0, 0xe3, 0xdd, 0xae, 0x49, 0xe8, 0x76, 0x07, 0x9d, 0x9b, 0x6d, 0x75, 0x95,
	0x4f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x25, 0xd7, 0xb0, 0xcf, 0x06, 0x00, 0x00,
}

func (m *ModuleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceCommandDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceCommandDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceCommandDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnhanceCustomCommand {
		i--
		if m.EnhanceCustomCommand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.SubCommands) > 0 {
		for k := range m.SubCommands {
			v := m.SubCommands[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOptions(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOptions(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOptions(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RpcCommandOptions) > 0 {
		for iNdEx := len(m.RpcCommandOptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpcCommandOptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RpcCommandOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcCommandOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcCommandOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovProposal {
		i--
		if m.GovProposal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Skip {
		i--
		if m.Skip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.PositionalArgs) > 0 {
		for iNdEx := len(m.PositionalArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionalArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FlagOptions) > 0 {
		for k := range m.FlagOptions {
			v := m.FlagOptions[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOptions(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOptions(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOptions(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Deprecated) > 0 {
		i -= len(m.Deprecated)
		copy(dAtA[i:], m.Deprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Deprecated)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SuggestFor) > 0 {
		for iNdEx := len(m.SuggestFor) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuggestFor[iNdEx])
			copy(dAtA[i:], m.SuggestFor[iNdEx])
			i = encodeVarintOptions(dAtA, i, uint64(len(m.SuggestFor[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Alias) > 0 {
		for iNdEx := len(m.Alias) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Alias[iNdEx])
			copy(dAtA[i:], m.Alias[iNdEx])
			i = encodeVarintOptions(dAtA, i, uint64(len(m.Alias[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Example) > 0 {
		i -= len(m.Example)
		copy(dAtA[i:], m.Example)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Example)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Short) > 0 {
		i -= len(m.Short)
		copy(dAtA[i:], m.Short)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Short)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Long) > 0 {
		i -= len(m.Long)
		copy(dAtA[i:], m.Long)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Long)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Use) > 0 {
		i -= len(m.Use)
		copy(dAtA[i:], m.Use)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Use)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RpcMethod) > 0 {
		i -= len(m.RpcMethod)
		copy(dAtA[i:], m.RpcMethod)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.RpcMethod)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlagOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlagOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlagOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ShorthandDeprecated) > 0 {
		i -= len(m.ShorthandDeprecated)
		copy(dAtA[i:], m.ShorthandDeprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.ShorthandDeprecated)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Deprecated) > 0 {
		i -= len(m.Deprecated)
		copy(dAtA[i:], m.Deprecated)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Deprecated)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Usage) > 0 {
		i -= len(m.Usage)
		copy(dAtA[i:], m.Usage)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Usage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Shorthand) > 0 {
		i -= len(m.Shorthand)
		copy(dAtA[i:], m.Shorthand)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Shorthand)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionalArgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionalArgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionalArgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Optional {
		i--
		if m.Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Varargs {
		i--
		if m.Varargs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProtoField) > 0 {
		i -= len(m.ProtoField)
		copy(dAtA[i:], m.ProtoField)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.ProtoField)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOptions(dAtA []byte, offset int, v uint64) int {
	offset -= sovOptions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModuleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovOptions(uint64(l))
	}
	return n
}

func (m *ServiceCommandDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.RpcCommandOptions) > 0 {
		for _, e := range m.RpcCommandOptions {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.SubCommands) > 0 {
		for k, v := range m.SubCommands {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOptions(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOptions(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOptions(uint64(mapEntrySize))
		}
	}
	if m.EnhanceCustomCommand {
		n += 2
	}
	return n
}

func (m *RpcCommandOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RpcMethod)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Use)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Long)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Short)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Example)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.Alias) > 0 {
		for _, s := range m.Alias {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.SuggestFor) > 0 {
		for _, s := range m.SuggestFor {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	l = len(m.Deprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.FlagOptions) > 0 {
		for k, v := range m.FlagOptions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOptions(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOptions(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOptions(uint64(mapEntrySize))
		}
	}
	if len(m.PositionalArgs) > 0 {
		for _, e := range m.PositionalArgs {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if m.Skip {
		n += 2
	}
	if m.GovProposal {
		n += 2
	}
	return n
}

func (m *FlagOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Shorthand)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Deprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.ShorthandDeprecated)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	return n
}

func (m *PositionalArgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtoField)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Varargs {
		n += 2
	}
	if m.Optional {
		n += 2
	}
	return n
}

func sovOptions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOptions(x uint64) (n int) {
	return sovOptions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModuleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &ServiceCommandDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &ServiceCommandDescriptor{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceCommandDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceCommandDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceCommandDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcCommandOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcCommandOptions = append(m.RpcCommandOptions, &RpcCommandOptions{})
			if err := m.RpcCommandOptions[len(m.RpcCommandOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubCommands == nil {
				m.SubCommands = make(map[string]*ServiceCommandDescriptor)
			}
			var mapkey string
			var mapvalue *ServiceCommandDescriptor
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOptions
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOptions
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceCommandDescriptor{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOptions(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOptions
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubCommands[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnhanceCustomCommand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnhanceCustomCommand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcCommandOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcCommandOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcCommandOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Use = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Long = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Short", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Short = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Example", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Example = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = append(m.Alias, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestFor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestFor = append(m.SuggestFor, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlagOptions == nil {
				m.FlagOptions = make(map[string]*FlagOptions)
			}
			var mapkey string
			var mapvalue *FlagOptions
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOptions
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOptions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOptions
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOptions
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FlagOptions{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOptions(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOptions
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FlagOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionalArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionalArgs = append(m.PositionalArgs, &PositionalArgDescriptor{})
			if err := m.PositionalArgs[len(m.PositionalArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skip = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovProposal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GovProposal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlagOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlagOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlagOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shorthand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shorthand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShorthandDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShorthandDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionalArgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionalArgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionalArgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Varargs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Varargs = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Optional = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOptions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOptions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOptions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOptions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOptions = fmt.Errorf("proto: unexpected end of group")
)
