// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: testpb/1.proto

package testpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	any "github.com/cosmos/gogoproto/types/any"
	_ "google.golang.org/protobuf/types/descriptorpb"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExternalEnum int32

const (
	ExternalEnum_One                 ExternalEnum = 0
	ExternalEnum_Two                 ExternalEnum = 1
	ExternalEnum_EXTERNAL_ENUM_THREE ExternalEnum = 127
)

var ExternalEnum_name = map[int32]string{
	0:   "One",
	1:   "Two",
	127: "EXTERNAL_ENUM_THREE",
}

var ExternalEnum_value = map[string]int32{
	"One":                 0,
	"Two":                 1,
	"EXTERNAL_ENUM_THREE": 127,
}

func (x ExternalEnum) String() string {
	return proto.EnumName(ExternalEnum_name, int32(x))
}

func (ExternalEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{0}
}

type BallotOption int32

const (
	BallotOption_BALLOT_OPTION_UNSPECIFIED  BallotOption = 0
	BallotOption_BALLOT_OPTION_YES          BallotOption = 1
	BallotOption_BALLOT_OPTION_ABSTAIN      BallotOption = 2
	BallotOption_BALLOT_OPTION_NO           BallotOption = 3
	BallotOption_BALLOT_OPTION_NO_WITH_VETO BallotOption = 4
)

var BallotOption_name = map[int32]string{
	0: "BALLOT_OPTION_UNSPECIFIED",
	1: "BALLOT_OPTION_YES",
	2: "BALLOT_OPTION_ABSTAIN",
	3: "BALLOT_OPTION_NO",
	4: "BALLOT_OPTION_NO_WITH_VETO",
}

var BallotOption_value = map[string]int32{
	"BALLOT_OPTION_UNSPECIFIED":  0,
	"BALLOT_OPTION_YES":          1,
	"BALLOT_OPTION_ABSTAIN":      2,
	"BALLOT_OPTION_NO":           3,
	"BALLOT_OPTION_NO_WITH_VETO": 4,
}

func (x BallotOption) String() string {
	return proto.EnumName(BallotOption_name, int32(x))
}

func (BallotOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{1}
}

type Baz_Internal_Enum int32

const (
	Baz_Four Baz_Internal_Enum = 0
	Baz_Five Baz_Internal_Enum = 1
)

var Baz_Internal_Enum_name = map[int32]string{
	0: "Four",
	1: "Five",
}

var Baz_Internal_Enum_value = map[string]int32{
	"Four": 0,
	"Five": 1,
}

func (x Baz_Internal_Enum) String() string {
	return proto.EnumName(Baz_Internal_Enum_name, int32(x))
}

func (Baz_Internal_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{3, 0}
}

// A is used for testing value renderers.
type A struct {
	// Fields that are parseable by SIGN_MODE_TEXTUAL.
	UINT32    uint32        `protobuf:"varint,1,opt,name=UINT32,proto3" json:"UINT32,omitempty"`
	UINT64    uint64        `protobuf:"varint,2,opt,name=UINT64,proto3" json:"UINT64,omitempty"`
	INT32     int32         `protobuf:"varint,3,opt,name=INT32,proto3" json:"INT32,omitempty"`
	INT64     int64         `protobuf:"varint,4,opt,name=INT64,proto3" json:"INT64,omitempty"`
	SDKINT    string        `protobuf:"bytes,5,opt,name=SDKINT,proto3" json:"SDKINT,omitempty"`
	SDKDEC    string        `protobuf:"bytes,6,opt,name=SDKDEC,proto3" json:"SDKDEC,omitempty"`
	COIN      *types.Coin   `protobuf:"bytes,7,opt,name=COIN,proto3" json:"COIN,omitempty"`
	COINS     []*types.Coin `protobuf:"bytes,8,rep,name=COINS,proto3" json:"COINS,omitempty"`
	BYTES     []byte        `protobuf:"bytes,9,opt,name=BYTES,proto3" json:"BYTES,omitempty"`
	TIMESTAMP time.Time     `protobuf:"bytes,10,opt,name=TIMESTAMP,proto3,stdtime" json:"TIMESTAMP"`
	DURATION  time.Duration `protobuf:"bytes,11,opt,name=DURATION,proto3,stdduration" json:"DURATION"`
	ENUM      ExternalEnum  `protobuf:"varint,12,opt,name=ENUM,proto3,enum=testpb.ExternalEnum" json:"ENUM,omitempty"`
	ANY       *any.Any      `protobuf:"bytes,13,opt,name=ANY,proto3" json:"ANY,omitempty"`
	// Fields that are not handled by SIGN_MODE_TEXTUAL.
	SINT32   int32         `protobuf:"zigzag32,101,opt,name=SINT32,proto3" json:"SINT32,omitempty"`
	SINT64   int64         `protobuf:"zigzag64,102,opt,name=SINT64,proto3" json:"SINT64,omitempty"`
	SFIXED32 int32         `protobuf:"fixed32,105,opt,name=SFIXED32,proto3" json:"SFIXED32,omitempty"`
	FIXED32  uint32        `protobuf:"fixed32,106,opt,name=FIXED32,proto3" json:"FIXED32,omitempty"`
	FLOAT    float32       `protobuf:"fixed32,107,opt,name=FLOAT,proto3" json:"FLOAT,omitempty"`
	SFIXED64 int64         `protobuf:"fixed64,108,opt,name=SFIXED64,proto3" json:"SFIXED64,omitempty"`
	FIXED64  uint64        `protobuf:"fixed64,109,opt,name=FIXED64,proto3" json:"FIXED64,omitempty"`
	DOUBLE   float64       `protobuf:"fixed64,110,opt,name=DOUBLE,proto3" json:"DOUBLE,omitempty"`
	MAP      map[string]*A `protobuf:"bytes,111,rep,name=MAP,proto3" json:"MAP,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *A) Reset()         { *m = A{} }
func (m *A) String() string { return proto.CompactTextString(m) }
func (*A) ProtoMessage()    {}
func (*A) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{0}
}
func (m *A) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A.Merge(m, src)
}
func (m *A) XXX_Size() int {
	return m.Size()
}
func (m *A) XXX_DiscardUnknown() {
	xxx_messageInfo_A.DiscardUnknown(m)
}

var xxx_messageInfo_A proto.InternalMessageInfo

func (m *A) GetUINT32() uint32 {
	if m != nil {
		return m.UINT32
	}
	return 0
}

func (m *A) GetUINT64() uint64 {
	if m != nil {
		return m.UINT64
	}
	return 0
}

func (m *A) GetINT32() int32 {
	if m != nil {
		return m.INT32
	}
	return 0
}

func (m *A) GetINT64() int64 {
	if m != nil {
		return m.INT64
	}
	return 0
}

func (m *A) GetSDKINT() string {
	if m != nil {
		return m.SDKINT
	}
	return ""
}

func (m *A) GetSDKDEC() string {
	if m != nil {
		return m.SDKDEC
	}
	return ""
}

func (m *A) GetCOIN() *types.Coin {
	if m != nil {
		return m.COIN
	}
	return nil
}

func (m *A) GetCOINS() []*types.Coin {
	if m != nil {
		return m.COINS
	}
	return nil
}

func (m *A) GetBYTES() []byte {
	if m != nil {
		return m.BYTES
	}
	return nil
}

func (m *A) GetTIMESTAMP() time.Time {
	if m != nil {
		return m.TIMESTAMP
	}
	return time.Time{}
}

func (m *A) GetDURATION() time.Duration {
	if m != nil {
		return m.DURATION
	}
	return 0
}

func (m *A) GetENUM() ExternalEnum {
	if m != nil {
		return m.ENUM
	}
	return ExternalEnum_One
}

func (m *A) GetANY() *any.Any {
	if m != nil {
		return m.ANY
	}
	return nil
}

func (m *A) GetSINT32() int32 {
	if m != nil {
		return m.SINT32
	}
	return 0
}

func (m *A) GetSINT64() int64 {
	if m != nil {
		return m.SINT64
	}
	return 0
}

func (m *A) GetSFIXED32() int32 {
	if m != nil {
		return m.SFIXED32
	}
	return 0
}

func (m *A) GetFIXED32() uint32 {
	if m != nil {
		return m.FIXED32
	}
	return 0
}

func (m *A) GetFLOAT() float32 {
	if m != nil {
		return m.FLOAT
	}
	return 0
}

func (m *A) GetSFIXED64() int64 {
	if m != nil {
		return m.SFIXED64
	}
	return 0
}

func (m *A) GetFIXED64() uint64 {
	if m != nil {
		return m.FIXED64
	}
	return 0
}

func (m *A) GetDOUBLE() float64 {
	if m != nil {
		return m.DOUBLE
	}
	return 0
}

func (m *A) GetMAP() map[string]*A {
	if m != nil {
		return m.MAP
	}
	return nil
}

// Foo is a sample message type used for testing message rendering.
type Foo struct {
	FullName string    `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Nickname string    `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Mtime    time.Time `protobuf:"bytes,3,opt,name=mtime,proto3,stdtime" json:"mtime"`
	Left     *Foo      `protobuf:"bytes,4,opt,name=left,proto3" json:"left,omitempty"`
	Right    *Foo      `protobuf:"bytes,5,opt,name=right,proto3" json:"right,omitempty"`
	Bar      *Bar      `protobuf:"bytes,8,opt,name=bar,proto3" json:"bar,omitempty"`
}

func (m *Foo) Reset()         { *m = Foo{} }
func (m *Foo) String() string { return proto.CompactTextString(m) }
func (*Foo) ProtoMessage()    {}
func (*Foo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{1}
}
func (m *Foo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Foo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Foo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Foo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Foo.Merge(m, src)
}
func (m *Foo) XXX_Size() int {
	return m.Size()
}
func (m *Foo) XXX_DiscardUnknown() {
	xxx_messageInfo_Foo.DiscardUnknown(m)
}

var xxx_messageInfo_Foo proto.InternalMessageInfo

func (m *Foo) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

func (m *Foo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *Foo) GetMtime() time.Time {
	if m != nil {
		return m.Mtime
	}
	return time.Time{}
}

func (m *Foo) GetLeft() *Foo {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *Foo) GetRight() *Foo {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *Foo) GetBar() *Bar {
	if m != nil {
		return m.Bar
	}
	return nil
}

// Bar is a sample message type used for testing message rendering.
type Bar struct {
	BarId   string   `protobuf:"bytes,1,opt,name=bar_id,json=barId,proto3" json:"bar_id,omitempty"`
	Data    []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Payload *any.Any `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Bar) Reset()         { *m = Bar{} }
func (m *Bar) String() string { return proto.CompactTextString(m) }
func (*Bar) ProtoMessage()    {}
func (*Bar) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{2}
}
func (m *Bar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bar.Merge(m, src)
}
func (m *Bar) XXX_Size() int {
	return m.Size()
}
func (m *Bar) XXX_DiscardUnknown() {
	xxx_messageInfo_Bar.DiscardUnknown(m)
}

var xxx_messageInfo_Bar proto.InternalMessageInfo

func (m *Bar) GetBarId() string {
	if m != nil {
		return m.BarId
	}
	return ""
}

func (m *Bar) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Bar) GetPayload() *any.Any {
	if m != nil {
		return m.Payload
	}
	return nil
}

// Baz is a sample message type used for testing enum rendering.
type Baz struct {
	Ee     ExternalEnum      `protobuf:"varint,1,opt,name=ee,proto3,enum=testpb.ExternalEnum" json:"ee,omitempty"`
	Ie     Baz_Internal_Enum `protobuf:"varint,2,opt,name=ie,proto3,enum=testpb.Baz_Internal_Enum" json:"ie,omitempty"`
	Option BallotOption      `protobuf:"varint,3,opt,name=option,proto3,enum=testpb.BallotOption" json:"option,omitempty"`
}

func (m *Baz) Reset()         { *m = Baz{} }
func (m *Baz) String() string { return proto.CompactTextString(m) }
func (*Baz) ProtoMessage()    {}
func (*Baz) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{3}
}
func (m *Baz) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Baz) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Baz.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Baz) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Baz.Merge(m, src)
}
func (m *Baz) XXX_Size() int {
	return m.Size()
}
func (m *Baz) XXX_DiscardUnknown() {
	xxx_messageInfo_Baz.DiscardUnknown(m)
}

var xxx_messageInfo_Baz proto.InternalMessageInfo

func (m *Baz) GetEe() ExternalEnum {
	if m != nil {
		return m.Ee
	}
	return ExternalEnum_One
}

func (m *Baz) GetIe() Baz_Internal_Enum {
	if m != nil {
		return m.Ie
	}
	return Baz_Four
}

func (m *Baz) GetOption() BallotOption {
	if m != nil {
		return m.Option
	}
	return BallotOption_BALLOT_OPTION_UNSPECIFIED
}

// Qux is a sample message type used for testing repeated rendering.
type Qux struct {
	Messages       []*Foo        `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	StringMessages []string      `protobuf:"bytes,2,rep,name=string_messages,json=stringMessages,proto3" json:"string_messages,omitempty"`
	Vote           *Ballot       `protobuf:"bytes,3,opt,name=vote,proto3" json:"vote,omitempty"`
	Price          []*types.Coin `protobuf:"bytes,4,rep,name=price,proto3" json:"price,omitempty"`
	Expirations    []time.Time   `protobuf:"bytes,5,rep,name=expirations,proto3,stdtime" json:"expirations"`
}

func (m *Qux) Reset()         { *m = Qux{} }
func (m *Qux) String() string { return proto.CompactTextString(m) }
func (*Qux) ProtoMessage()    {}
func (*Qux) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{4}
}
func (m *Qux) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Qux) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Qux.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Qux) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Qux.Merge(m, src)
}
func (m *Qux) XXX_Size() int {
	return m.Size()
}
func (m *Qux) XXX_DiscardUnknown() {
	xxx_messageInfo_Qux.DiscardUnknown(m)
}

var xxx_messageInfo_Qux proto.InternalMessageInfo

func (m *Qux) GetMessages() []*Foo {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *Qux) GetStringMessages() []string {
	if m != nil {
		return m.StringMessages
	}
	return nil
}

func (m *Qux) GetVote() *Ballot {
	if m != nil {
		return m.Vote
	}
	return nil
}

func (m *Qux) GetPrice() []*types.Coin {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *Qux) GetExpirations() []time.Time {
	if m != nil {
		return m.Expirations
	}
	return nil
}

type WeightedBallotOption struct {
	// TODO: Enumeration rendering
	// BallotOption option = 1;
	Option string `protobuf:"bytes,1,opt,name=option,proto3" json:"option,omitempty"`
	Weight string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightedBallotOption) Reset()         { *m = WeightedBallotOption{} }
func (m *WeightedBallotOption) String() string { return proto.CompactTextString(m) }
func (*WeightedBallotOption) ProtoMessage()    {}
func (*WeightedBallotOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{5}
}
func (m *WeightedBallotOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeightedBallotOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeightedBallotOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeightedBallotOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeightedBallotOption.Merge(m, src)
}
func (m *WeightedBallotOption) XXX_Size() int {
	return m.Size()
}
func (m *WeightedBallotOption) XXX_DiscardUnknown() {
	xxx_messageInfo_WeightedBallotOption.DiscardUnknown(m)
}

var xxx_messageInfo_WeightedBallotOption proto.InternalMessageInfo

func (m *WeightedBallotOption) GetOption() string {
	if m != nil {
		return m.Option
	}
	return ""
}

func (m *WeightedBallotOption) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

type Ballot struct {
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// TODO: cosmos.AddressString rendering
	// string voter       = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
	Voter   string                  `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	Options []*WeightedBallotOption `protobuf:"bytes,4,rep,name=options,proto3" json:"options,omitempty"`
}

func (m *Ballot) Reset()         { *m = Ballot{} }
func (m *Ballot) String() string { return proto.CompactTextString(m) }
func (*Ballot) ProtoMessage()    {}
func (*Ballot) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6ff308d568b2923, []int{6}
}
func (m *Ballot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ballot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ballot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ballot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ballot.Merge(m, src)
}
func (m *Ballot) XXX_Size() int {
	return m.Size()
}
func (m *Ballot) XXX_DiscardUnknown() {
	xxx_messageInfo_Ballot.DiscardUnknown(m)
}

var xxx_messageInfo_Ballot proto.InternalMessageInfo

func (m *Ballot) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Ballot) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Ballot) GetOptions() []*WeightedBallotOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func init() {
	proto.RegisterEnum("testpb.ExternalEnum", ExternalEnum_name, ExternalEnum_value)
	proto.RegisterEnum("testpb.BallotOption", BallotOption_name, BallotOption_value)
	proto.RegisterEnum("testpb.Baz_Internal_Enum", Baz_Internal_Enum_name, Baz_Internal_Enum_value)
	proto.RegisterType((*A)(nil), "testpb.A")
	proto.RegisterMapType((map[string]*A)(nil), "testpb.A.MAPEntry")
	proto.RegisterType((*Foo)(nil), "testpb.Foo")
	proto.RegisterType((*Bar)(nil), "testpb.Bar")
	proto.RegisterType((*Baz)(nil), "testpb.Baz")
	proto.RegisterType((*Qux)(nil), "testpb.Qux")
	proto.RegisterType((*WeightedBallotOption)(nil), "testpb.WeightedBallotOption")
	proto.RegisterType((*Ballot)(nil), "testpb.Ballot")
}

func init() { proto.RegisterFile("testpb/1.proto", fileDescriptor_c6ff308d568b2923) }

var fileDescriptor_c6ff308d568b2923 = []byte{
	// 1167 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x72, 0x1b, 0x45,
	0x17, 0x55, 0x6b, 0x24, 0x59, 0xba, 0xb2, 0x9d, 0x49, 0x7f, 0xce, 0xc7, 0xd8, 0x10, 0x79, 0x10,
	0xa9, 0x64, 0x48, 0x11, 0xa9, 0xa2, 0xb8, 0x5c, 0xc0, 0x86, 0x1a, 0x59, 0x63, 0x32, 0xc4, 0x96,
	0x4c, 0x6b, 0x9c, 0x9f, 0x95, 0x18, 0x59, 0x6d, 0x31, 0x44, 0x9a, 0x56, 0xcd, 0x8c, 0x9c, 0x38,
	0x55, 0x14, 0xaf, 0x90, 0x0d, 0x55, 0x3c, 0x02, 0xec, 0x58, 0xb0, 0xe1, 0x0d, 0xb2, 0x4c, 0xb1,
	0x62, 0x05, 0x94, 0xb3, 0xe0, 0x19, 0xd8, 0x51, 0xfd, 0x33, 0xb2, 0x65, 0x07, 0xa8, 0x6c, 0xa4,
	0x39, 0xf7, 0x9c, 0xbe, 0xdd, 0x7d, 0xef, 0xe9, 0x0b, 0xcb, 0x09, 0x8d, 0x93, 0x49, 0xbf, 0x7e,
	0xbb, 0x36, 0x89, 0x58, 0xc2, 0x70, 0x41, 0xe2, 0xb5, 0xca, 0x01, 0x8b, 0xc7, 0x2c, 0xae, 0xf7,
	0xfd, 0x98, 0xd6, 0x8f, 0x6e, 0xf7, 0x69, 0xe2, 0xdf, 0xae, 0x1f, 0xb0, 0x20, 0x94, 0xba, 0xb5,
	0x55, 0xc9, 0xf7, 0x04, 0xaa, 0x4b, 0x90, 0x52, 0x43, 0xc6, 0x86, 0x23, 0x5a, 0x17, 0xa8, 0x3f,
	0x3d, 0xac, 0xfb, 0xe1, 0xb1, 0xa2, 0xcc, 0xf3, 0xd4, 0x80, 0xc6, 0x07, 0x51, 0x30, 0x49, 0x58,
	0xa4, 0x14, 0x95, 0x0b, 0x8a, 0x69, 0xe4, 0x27, 0x01, 0x4b, 0xf7, 0x5d, 0x3f, 0xcf, 0x27, 0xc1,
	0x98, 0xc6, 0x89, 0x3f, 0x9e, 0x28, 0xc1, 0x65, 0x7f, 0x1c, 0x84, 0xac, 0x2e, 0x7e, 0x55, 0x68,
	0x65, 0xc8, 0x86, 0x4c, 0x1e, 0x94, 0x7f, 0xc9, 0x68, 0xf5, 0xe7, 0x02, 0x20, 0x1b, 0xff, 0x1f,
	0x0a, 0xfb, 0x6e, 0xdb, 0xbb, 0xd3, 0x30, 0x90, 0x89, 0xac, 0x25, 0xa2, 0x50, 0x1a, 0xdf, 0xdc,
	0x30, 0xb2, 0x26, 0xb2, 0x72, 0x44, 0x21, 0xbc, 0x02, 0x79, 0x29, 0xd7, 0x4c, 0x64, 0xe5, 0x89,
	0x04, 0x2a, 0xba, 0xb9, 0x61, 0xe4, 0x4c, 0x64, 0x69, 0x44, 0x02, 0x7c, 0x1d, 0x0a, 0xdd, 0xd6,
	0x3d, 0xb7, 0xed, 0x19, 0x79, 0x13, 0x59, 0xa5, 0xe6, 0xf2, 0x2f, 0x3f, 0xdd, 0x02, 0x55, 0x2a,
	0x37, 0x4c, 0x88, 0x62, 0x95, 0xae, 0xe5, 0x6c, 0x19, 0x85, 0x0b, 0xba, 0x16, 0x3d, 0x20, 0x8a,
	0xc5, 0xb7, 0x20, 0xb7, 0xd5, 0x71, 0xdb, 0xc6, 0x82, 0x89, 0xac, 0x72, 0x63, 0xb5, 0xa6, 0x24,
	0xbc, 0x45, 0x35, 0xd5, 0xa2, 0xda, 0x16, 0x0b, 0x42, 0x22, 0x64, 0xb8, 0x0e, 0x79, 0xfe, 0xdf,
	0x35, 0x8a, 0xa6, 0xf6, 0xef, 0x7a, 0xa9, 0xe3, 0xb7, 0x68, 0x3e, 0xf2, 0x9c, 0xae, 0x51, 0x32,
	0x91, 0xb5, 0x48, 0x24, 0xc0, 0x9f, 0x42, 0xc9, 0x73, 0x77, 0x9d, 0xae, 0x67, 0xef, 0xee, 0x19,
	0x20, 0xb6, 0x5e, 0xab, 0xc9, 0x2e, 0xd4, 0xd2, 0x2e, 0xd4, 0xbc, 0xb4, 0x0b, 0xcd, 0xa5, 0x17,
	0xbf, 0xad, 0x67, 0x9e, 0xff, 0xbe, 0x8e, 0xbe, 0xff, 0xf3, 0xc7, 0x9b, 0x88, 0x9c, 0xae, 0xc5,
	0x2d, 0x28, 0xb6, 0xf6, 0x89, 0xed, 0xb9, 0x9d, 0xb6, 0x51, 0x56, 0x57, 0x38, 0x9f, 0xa7, 0xa5,
	0xba, 0x2d, 0xd3, 0x7c, 0x37, 0x4b, 0x33, 0x5b, 0x89, 0x2d, 0xc8, 0x39, 0xed, 0xfd, 0x5d, 0x63,
	0xd1, 0x44, 0xd6, 0x72, 0x63, 0xa5, 0x26, 0xfd, 0x5a, 0x73, 0x9e, 0x26, 0x34, 0x0a, 0xfd, 0x91,
	0x13, 0x4e, 0xc7, 0x44, 0x28, 0xf0, 0x75, 0xd0, 0xec, 0xf6, 0x23, 0x63, 0x49, 0x6c, 0xb5, 0x72,
	0x61, 0x2b, 0x3b, 0x3c, 0x26, 0x5c, 0xc0, 0x5b, 0xdd, 0x95, 0x3d, 0xa5, 0x26, 0xb2, 0x2e, 0x13,
	0x85, 0xd2, 0xf8, 0xe6, 0x86, 0x71, 0x68, 0x22, 0x0b, 0x13, 0x85, 0xf0, 0x1a, 0x14, 0xbb, 0xdb,
	0xee, 0x43, 0xa7, 0x75, 0xa7, 0x61, 0x04, 0x26, 0xb2, 0x2e, 0x91, 0x19, 0xc6, 0x06, 0x2c, 0xa4,
	0xd4, 0x57, 0x26, 0xb2, 0x16, 0x48, 0x0a, 0x79, 0x71, 0xb7, 0x77, 0x3a, 0xb6, 0x67, 0x3c, 0x36,
	0x91, 0x95, 0x25, 0x12, 0x9c, 0xe6, 0xda, 0xdc, 0x30, 0x46, 0x26, 0xb2, 0x74, 0x32, 0xc3, 0xb3,
	0x5c, 0x9b, 0x1b, 0xc6, 0xd8, 0x44, 0x56, 0x81, 0xa4, 0x90, 0x9f, 0xac, 0xd5, 0xd9, 0x6f, 0xee,
	0x38, 0x46, 0x68, 0x22, 0x0b, 0x11, 0x85, 0xf0, 0x35, 0xd0, 0x76, 0xed, 0x3d, 0x83, 0x89, 0x7e,
	0xe3, 0xb4, 0x34, 0x76, 0x6d, 0xd7, 0xde, 0x73, 0xc2, 0x24, 0x3a, 0x26, 0x9c, 0x5e, 0xb3, 0xa1,
	0x98, 0x06, 0xb0, 0x0e, 0xda, 0x63, 0x7a, 0x2c, 0xbc, 0x5f, 0x22, 0xfc, 0x13, 0xaf, 0x43, 0xfe,
	0xc8, 0x1f, 0x4d, 0xa9, 0xf0, 0x7d, 0xb9, 0x51, 0x9a, 0x65, 0x21, 0x32, 0xfe, 0x71, 0xf6, 0x43,
	0x54, 0x3d, 0x41, 0xa0, 0x6d, 0x33, 0x86, 0xdf, 0x86, 0xd2, 0xe1, 0x74, 0x34, 0xea, 0x85, 0xfe,
	0x98, 0xaa, 0x24, 0x45, 0x1e, 0x68, 0xfb, 0x63, 0xca, 0xef, 0x16, 0x06, 0x07, 0x8f, 0x05, 0x97,
	0x95, 0x5c, 0x8a, 0xf1, 0x27, 0x90, 0x1f, 0xf3, 0x97, 0x2b, 0x9e, 0xd1, 0x1b, 0x19, 0x4a, 0xae,
	0xc3, 0xeb, 0x90, 0x1b, 0xd1, 0xc3, 0x44, 0x3c, 0xb8, 0x72, 0xa3, 0x9c, 0x9e, 0x72, 0x9b, 0x31,
	0x22, 0x08, 0xfc, 0x2e, 0xe4, 0xa3, 0x60, 0xf8, 0x65, 0x22, 0xde, 0xde, 0x39, 0x85, 0x64, 0xf0,
	0x55, 0xd0, 0xfa, 0x7e, 0x64, 0x14, 0xe7, 0x05, 0x4d, 0x3f, 0x22, 0x3c, 0x5e, 0xfd, 0x02, 0xb4,
	0xa6, 0x1f, 0xe1, 0x2b, 0x50, 0xe8, 0xfb, 0x51, 0x2f, 0x18, 0xa8, 0x0b, 0xe6, 0xfb, 0x7e, 0xe4,
	0x0e, 0x30, 0x86, 0xdc, 0xc0, 0x4f, 0x7c, 0x71, 0xb3, 0x45, 0x22, 0xbe, 0x71, 0x0d, 0x16, 0x26,
	0xfe, 0xf1, 0x88, 0xf9, 0x03, 0x75, 0xaf, 0xd7, 0xbb, 0x2e, 0x15, 0x55, 0x7f, 0x40, 0x7c, 0x8b,
	0x67, 0xf8, 0x1a, 0x64, 0xa9, 0xac, 0xdf, 0x3f, 0x39, 0x3a, 0x4b, 0x29, 0x7e, 0x1f, 0xb2, 0x81,
	0xac, 0xe4, 0x72, 0x63, 0xf5, 0xf4, 0xb4, 0xcf, 0xf8, 0x2c, 0x11, 0xca, 0x9e, 0x94, 0x06, 0x14,
	0x7f, 0x00, 0x05, 0x36, 0xe1, 0xef, 0x48, 0x9c, 0xe3, 0x4c, 0xd2, 0xa6, 0x3f, 0x1a, 0xb1, 0xa4,
	0x23, 0x38, 0xa2, 0x34, 0xd5, 0xf7, 0x60, 0x69, 0x2e, 0x05, 0x2e, 0x42, 0x6e, 0x9b, 0x4d, 0x23,
	0x3d, 0x23, 0xbe, 0x82, 0x23, 0xaa, 0xa3, 0xea, 0x5f, 0x08, 0xb4, 0xcf, 0xa7, 0x4f, 0xf1, 0x0d,
	0x28, 0x8e, 0x69, 0x1c, 0xfb, 0x43, 0x1a, 0x1b, 0x48, 0x18, 0x6d, 0xae, 0xb4, 0x33, 0x12, 0xdf,
	0x80, 0x4b, 0x71, 0x12, 0x05, 0xe1, 0xb0, 0x37, 0xd3, 0x67, 0x4d, 0xcd, 0x2a, 0x91, 0x65, 0x19,
	0xde, 0x4d, 0x85, 0x55, 0xc8, 0x1d, 0xb1, 0x24, 0xb5, 0xc2, 0xf2, 0xfc, 0x51, 0x89, 0xe0, 0xf8,
	0x2c, 0x9b, 0x44, 0xc1, 0x01, 0x35, 0x72, 0xff, 0x39, 0xcb, 0x84, 0x0e, 0xdf, 0x83, 0x32, 0x7d,
	0x3a, 0x09, 0xe4, 0x34, 0x89, 0x8d, 0xbc, 0x58, 0xf6, 0x06, 0x36, 0x3b, 0xbb, 0xba, 0x7a, 0x1f,
	0x56, 0x1e, 0x50, 0x6e, 0x19, 0x3a, 0x38, 0x5b, 0x40, 0xfe, 0x0e, 0x55, 0x99, 0xa5, 0x35, 0x14,
	0xe2, 0x03, 0xfd, 0x89, 0xd0, 0x4b, 0xdf, 0x5f, 0x1c, 0xe8, 0x92, 0xad, 0x7e, 0x0d, 0x05, 0x99,
	0x0f, 0xaf, 0x43, 0x79, 0x12, 0xb1, 0x09, 0x8b, 0xfd, 0x51, 0xea, 0xb4, 0x1c, 0x81, 0x34, 0xe4,
	0x0e, 0xf8, 0xf8, 0xe0, 0x85, 0x88, 0xd4, 0x4b, 0x92, 0x00, 0x6f, 0xc2, 0x82, 0xdc, 0x32, 0x56,
	0x85, 0x79, 0x27, 0xad, 0xde, 0xeb, 0xce, 0x4b, 0x52, 0xf1, 0x67, 0xb9, 0xa2, 0xa6, 0xe7, 0x6e,
	0x7e, 0x04, 0x8b, 0x67, 0x4d, 0x86, 0x17, 0x40, 0xeb, 0x84, 0x54, 0xcf, 0xf0, 0x0f, 0xef, 0x09,
	0xd3, 0x11, 0x7e, 0x0b, 0xfe, 0xe7, 0x3c, 0xf4, 0x1c, 0xd2, 0xb6, 0x77, 0x7a, 0x7c, 0xa6, 0xf6,
	0xbc, 0xbb, 0xc4, 0x71, 0xf4, 0x6f, 0x6e, 0x7e, 0x8b, 0x60, 0x71, 0xae, 0x14, 0x57, 0x61, 0xb5,
	0x69, 0xef, 0xec, 0x74, 0xbc, 0x5e, 0x67, 0x8f, 0xcf, 0xe9, 0xde, 0x7e, 0xbb, 0xbb, 0xe7, 0x6c,
	0xb9, 0xdb, 0xae, 0xd3, 0xd2, 0x33, 0xf8, 0x0a, 0x5c, 0x9e, 0xa7, 0x1f, 0x39, 0x5d, 0x1d, 0xe1,
	0x55, 0xb8, 0x32, 0x1f, 0xb6, 0x9b, 0x5d, 0xcf, 0x76, 0xdb, 0x7a, 0x16, 0xaf, 0x80, 0x3e, 0x4f,
	0xb5, 0x3b, 0xba, 0x86, 0x2b, 0xb0, 0x76, 0x3e, 0xda, 0x7b, 0xe0, 0x7a, 0x77, 0x7b, 0xf7, 0x1d,
	0xaf, 0xa3, 0xe7, 0x9a, 0xc6, 0x8b, 0x93, 0x0a, 0x7a, 0x79, 0x52, 0x41, 0x7f, 0x9c, 0x54, 0xd0,
	0xf3, 0x57, 0x95, 0xcc, 0xcb, 0x57, 0x95, 0xcc, 0xaf, 0xaf, 0x2a, 0x99, 0x7e, 0x41, 0xf4, 0xfc,
	0xce, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe3, 0xc1, 0xfb, 0x7e, 0xf1, 0x08, 0x00, 0x00,
}

func (m *A) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MAP) > 0 {
		for k := range m.MAP {
			v := m.MAP[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarint1(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint1(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint1(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.DOUBLE != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DOUBLE))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf1
	}
	if m.FIXED64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.FIXED64))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe9
	}
	if m.SFIXED64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SFIXED64))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe1
	}
	if m.FLOAT != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FLOAT))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xdd
	}
	if m.FIXED32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.FIXED32))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd5
	}
	if m.SFIXED32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.SFIXED32))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xcd
	}
	if m.SINT64 != 0 {
		i = encodeVarint1(dAtA, i, uint64((uint64(m.SINT64)<<1)^uint64((m.SINT64>>63))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.SINT32 != 0 {
		i = encodeVarint1(dAtA, i, uint64((uint32(m.SINT32)<<1)^uint32((m.SINT32>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.ANY != nil {
		{
			size, err := m.ANY.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ENUM != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.ENUM))
		i--
		dAtA[i] = 0x60
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.DURATION, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.DURATION):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarint1(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x5a
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.TIMESTAMP, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TIMESTAMP):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarint1(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x52
	if len(m.BYTES) > 0 {
		i -= len(m.BYTES)
		copy(dAtA[i:], m.BYTES)
		i = encodeVarint1(dAtA, i, uint64(len(m.BYTES)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.COINS) > 0 {
		for iNdEx := len(m.COINS) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.COINS[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint1(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.COIN != nil {
		{
			size, err := m.COIN.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SDKDEC) > 0 {
		i -= len(m.SDKDEC)
		copy(dAtA[i:], m.SDKDEC)
		i = encodeVarint1(dAtA, i, uint64(len(m.SDKDEC)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SDKINT) > 0 {
		i -= len(m.SDKINT)
		copy(dAtA[i:], m.SDKINT)
		i = encodeVarint1(dAtA, i, uint64(len(m.SDKINT)))
		i--
		dAtA[i] = 0x2a
	}
	if m.INT64 != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.INT64))
		i--
		dAtA[i] = 0x20
	}
	if m.INT32 != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.INT32))
		i--
		dAtA[i] = 0x18
	}
	if m.UINT64 != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.UINT64))
		i--
		dAtA[i] = 0x10
	}
	if m.UINT32 != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.UINT32))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Foo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Foo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Foo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bar != nil {
		{
			size, err := m.Bar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Mtime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Mtime):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarint1(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x1a
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarint1(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FullName) > 0 {
		i -= len(m.FullName)
		copy(dAtA[i:], m.FullName)
		i = encodeVarint1(dAtA, i, uint64(len(m.FullName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Bar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarint1(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BarId) > 0 {
		i -= len(m.BarId)
		copy(dAtA[i:], m.BarId)
		i = encodeVarint1(dAtA, i, uint64(len(m.BarId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Baz) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Baz) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Baz) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x18
	}
	if m.Ie != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.Ie))
		i--
		dAtA[i] = 0x10
	}
	if m.Ee != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.Ee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Qux) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Qux) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Qux) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Expirations) > 0 {
		for iNdEx := len(m.Expirations) - 1; iNdEx >= 0; iNdEx-- {
			n, err := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Expirations[iNdEx], dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Expirations[iNdEx]):])
			if err != nil {
				return 0, err
			}
			i -= n
			i = encodeVarint1(dAtA, i, uint64(n))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Price[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint1(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint1(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StringMessages) > 0 {
		for iNdEx := len(m.StringMessages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringMessages[iNdEx])
			copy(dAtA[i:], m.StringMessages[iNdEx])
			i = encodeVarint1(dAtA, i, uint64(len(m.StringMessages[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint1(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WeightedBallotOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedBallotOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeightedBallotOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarint1(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Option) > 0 {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarint1(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ballot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ballot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ballot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint1(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarint1(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarint1(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarint1(dAtA []byte, offset int, v uint64) int {
	offset -= sov1(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UINT32 != 0 {
		n += 1 + sov1(uint64(m.UINT32))
	}
	if m.UINT64 != 0 {
		n += 1 + sov1(uint64(m.UINT64))
	}
	if m.INT32 != 0 {
		n += 1 + sov1(uint64(m.INT32))
	}
	if m.INT64 != 0 {
		n += 1 + sov1(uint64(m.INT64))
	}
	l = len(m.SDKINT)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = len(m.SDKDEC)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	if m.COIN != nil {
		l = m.COIN.Size()
		n += 1 + l + sov1(uint64(l))
	}
	if len(m.COINS) > 0 {
		for _, e := range m.COINS {
			l = e.Size()
			n += 1 + l + sov1(uint64(l))
		}
	}
	l = len(m.BYTES)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TIMESTAMP)
	n += 1 + l + sov1(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.DURATION)
	n += 1 + l + sov1(uint64(l))
	if m.ENUM != 0 {
		n += 1 + sov1(uint64(m.ENUM))
	}
	if m.ANY != nil {
		l = m.ANY.Size()
		n += 1 + l + sov1(uint64(l))
	}
	if m.SINT32 != 0 {
		n += 2 + soz1(uint64(m.SINT32))
	}
	if m.SINT64 != 0 {
		n += 2 + soz1(uint64(m.SINT64))
	}
	if m.SFIXED32 != 0 {
		n += 6
	}
	if m.FIXED32 != 0 {
		n += 6
	}
	if m.FLOAT != 0 {
		n += 6
	}
	if m.SFIXED64 != 0 {
		n += 10
	}
	if m.FIXED64 != 0 {
		n += 10
	}
	if m.DOUBLE != 0 {
		n += 10
	}
	if len(m.MAP) > 0 {
		for k, v := range m.MAP {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sov1(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sov1(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov1(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Foo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FullName)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Mtime)
	n += 1 + l + sov1(uint64(l))
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sov1(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sov1(uint64(l))
	}
	if m.Bar != nil {
		l = m.Bar.Size()
		n += 1 + l + sov1(uint64(l))
	}
	return n
}

func (m *Bar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BarId)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sov1(uint64(l))
	}
	return n
}

func (m *Baz) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ee != 0 {
		n += 1 + sov1(uint64(m.Ee))
	}
	if m.Ie != 0 {
		n += 1 + sov1(uint64(m.Ie))
	}
	if m.Option != 0 {
		n += 1 + sov1(uint64(m.Option))
	}
	return n
}

func (m *Qux) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sov1(uint64(l))
		}
	}
	if len(m.StringMessages) > 0 {
		for _, s := range m.StringMessages {
			l = len(s)
			n += 1 + l + sov1(uint64(l))
		}
	}
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sov1(uint64(l))
	}
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			l = e.Size()
			n += 1 + l + sov1(uint64(l))
		}
	}
	if len(m.Expirations) > 0 {
		for _, e := range m.Expirations {
			l = github_com_cosmos_gogoproto_types.SizeOfStdTime(e)
			n += 1 + l + sov1(uint64(l))
		}
	}
	return n
}

func (m *WeightedBallotOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Option)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	return n
}

func (m *Ballot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sov1(uint64(m.ProposalId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sov1(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sov1(uint64(l))
		}
	}
	return n
}

func sov1(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func soz1(x uint64) (n int) {
	return sov1(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UINT32", wireType)
			}
			m.UINT32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UINT32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UINT64", wireType)
			}
			m.UINT64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UINT64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INT32", wireType)
			}
			m.INT32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.INT32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INT64", wireType)
			}
			m.INT64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.INT64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SDKINT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SDKINT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SDKDEC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SDKDEC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field COIN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.COIN == nil {
				m.COIN = &types.Coin{}
			}
			if err := m.COIN.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field COINS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.COINS = append(m.COINS, &types.Coin{})
			if err := m.COINS[len(m.COINS)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BYTES", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BYTES = append(m.BYTES[:0], dAtA[iNdEx:postIndex]...)
			if m.BYTES == nil {
				m.BYTES = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TIMESTAMP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.TIMESTAMP, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DURATION", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.DURATION, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ENUM", wireType)
			}
			m.ENUM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ENUM |= ExternalEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ANY", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ANY == nil {
				m.ANY = &any.Any{}
			}
			if err := m.ANY.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SINT32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SINT32 = v
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SINT64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.SINT64 = int64(v)
		case 105:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SFIXED32", wireType)
			}
			m.SFIXED32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.SFIXED32 = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 106:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIXED32", wireType)
			}
			m.FIXED32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.FIXED32 = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 107:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FLOAT", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.FLOAT = float32(math.Float32frombits(v))
		case 108:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SFIXED64", wireType)
			}
			m.SFIXED64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SFIXED64 = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 109:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIXED64", wireType)
			}
			m.FIXED64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.FIXED64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 110:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DOUBLE", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DOUBLE = float64(math.Float64frombits(v))
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MAP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MAP == nil {
				m.MAP = make(map[string]*A)
			}
			var mapkey string
			var mapvalue *A
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow1
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow1
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength1
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength1
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow1
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength1
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength1
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &A{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip1(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength1
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MAP[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Foo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Foo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Foo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Mtime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &Foo{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &Foo{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bar == nil {
				m.Bar = &Bar{}
			}
			if err := m.Bar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BarId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BarId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &any.Any{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Baz) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Baz: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Baz: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ee", wireType)
			}
			m.Ee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ee |= ExternalEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ie", wireType)
			}
			m.Ie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ie |= Baz_Internal_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= BallotOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Qux) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Qux: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Qux: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Foo{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMessages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringMessages = append(m.StringMessages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &Ballot{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = append(m.Price, &types.Coin{})
			if err := m.Price[len(m.Price)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expirations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expirations = append(m.Expirations, time.Time{})
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&(m.Expirations[len(m.Expirations)-1]), dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedBallotOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedBallotOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedBallotOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ballot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ballot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ballot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength1
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength1
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &WeightedBallotOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skip1(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow1
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow1
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow1
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLength1
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroup1
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLength1
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLength1        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow1          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroup1 = fmt.Errorf("proto: unexpected end of group")
)
